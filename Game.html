<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Protocol: OVERRIDE</title>
    <style>
        :root {
            --neon-green: #0f0;
            --neon-cyan: #0ff;
            --neon-purple: #f0f;
            --neon-red: #f00;
            --bg-color: #050505;
            --ui-bg: rgba(0, 10, 0, 0.85);
        }
        
        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: 'Courier New', Courier, monospace;
            color: var(--neon-green);
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            touch-action: none; /* Prevent scrolling during gameplay */
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Overlays */
        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud {
            padding: 10px;
            display: flex;
            justify-content: space-between;
            font-size: 16px;
            text-shadow: 0 0 5px var(--neon-green);
        }

        .xp-bar-container {
            width: 100%;
            height: 10px;
            background: #111;
            border: 1px solid var(--neon-cyan);
            margin-top: 5px;
            position: relative;
        }

        .xp-bar-fill {
            height: 100%;
            background: var(--neon-cyan);
            width: 0%;
            box-shadow: 0 0 8px var(--neon-cyan);
            transition: width 0.2s;
        }

        /* Screens */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            pointer-events: auto;
            z-index: 10;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 40px;
            text-shadow: 0 0 10px var(--neon-purple), 0 0 20px var(--neon-purple);
            margin-bottom: 20px;
            text-align: center;
            letter-spacing: 2px;
        }
        
        .btn {
            background: transparent;
            color: var(--neon-green);
            border: 2px solid var(--neon-green);
            padding: 15px 30px;
            font-family: inherit;
            font-size: 18px;
            margin: 10px;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
            transition: all 0.2s;
            pointer-events: auto;
        }

        .btn:active {
            background: var(--neon-green);
            color: black;
            box-shadow: 0 0 20px var(--neon-green);
        }

        .btn:disabled {
            border-color: #555;
            color: #555;
            pointer-events: none;
            box-shadow: none;
        }

        /* Hack Modal */
        #hack-modal {
            background: rgba(0, 20, 0, 0.95);
            border: 2px solid var(--neon-green);
            width: 90%;
            max-width: 400px;
            height: auto;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 20;
            pointer-events: auto;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.3);
        }

        #timer-bar {
            width: 100%;
            height: 5px;
            background: #333;
            margin-bottom: 15px;
        }
        #timer-fill {
            width: 100%;
            height: 100%;
            background: var(--neon-red);
        }

        .hack-question {
            font-size: 20px;
            margin-bottom: 20px;
            text-align: center;
        }

        .hack-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            width: 100%;
        }

        .hack-btn {
            padding: 15px;
            background: rgba(0, 50, 0, 0.5);
            border: 1px solid var(--neon-cyan);
            color: var(--neon-cyan);
            font-size: 16px;
        }

        /* Joystick Hint */
        #joystick-zone {
            position: absolute;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 120px;
            height: 120px;
            border: 2px dashed rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            pointer-events: none;
        }

        /* Damage Numbers */
        .floater {
            position: absolute;
            pointer-events: none;
            font-weight: bold;
            animation: floatUp 0.8s ease-out forwards;
        }

        @keyframes floatUp {
            0% { transform: translateY(0) scale(1); opacity: 1; }
            100% { transform: translateY(-30px) scale(1.5); opacity: 0; }
        }

        .level-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            max-height: 300px;
            overflow-y: auto;
            width: 100%;
            padding: 10px;
            pointer-events: auto;
        }

        /* Shop Skin Cards */
        .skin-card {
            background: rgba(0, 20, 0, 0.9);
            border: 2px solid #444;
            border-radius: 8px;
            padding: 10px;
            text-align: center;
            transition: all 0.2s;
        }
        .skin-card.owned {
            border-color: var(--neon-green);
        }
        .skin-card.equipped {
            border-color: #ff0;
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.3);
        }
        .skin-card .preview {
            width: 50px;
            height: 70px;
            margin: 0 auto 8px;
            position: relative;
        }
        .skin-card .skin-name {
            font-size: 12px;
            color: #fff;
            margin-bottom: 5px;
        }
        .skin-card .skin-price {
            font-size: 11px;
            color: #ff0;
            margin-bottom: 8px;
        }
        .skin-card .skin-btn {
            width: 100%;
            padding: 6px 10px;
            font-size: 11px;
            border: 1px solid;
            background: transparent;
            cursor: pointer;
            font-family: inherit;
            text-transform: uppercase;
        }
        .skin-card .skin-btn.buy {
            border-color: #ff0;
            color: #ff0;
        }
        .skin-card .skin-btn.equip {
            border-color: var(--neon-green);
            color: var(--neon-green);
        }
        .skin-card .skin-btn.equipped {
            border-color: #888;
            color: #888;
            cursor: default;
        }
        .skin-card .skin-btn.locked {
            border-color: #666;
            color: #666;
            cursor: not-allowed;
        }
    </style>

</head>
<body>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    <div id="joystick-zone"></div>

    <!-- HUD -->
    <div id="game-ui" class="ui-layer hidden">
        <div style="width: 100%; display: flex; justify-content: space-between; align-items: flex-start; padding: 10px; box-sizing: border-box;">
            <!-- Left: DATA -->
            <div style="flex: 1;">
                <div class="hud" style="justify-content: flex-start;">
                    <span id="score-display">DATA: 0%</span>
                </div>
                <div class="xp-bar-container">
                    <div id="xp-bar" class="xp-bar-fill"></div>
                </div>
            </div>
            
            <!-- Center: Timer & Coins -->
            <div style="flex: 1; text-align: center;">
                <span id="time-display" style="font-size: 24px; color: var(--neon-green); text-shadow: 0 0 10px var(--neon-green);">2:00</span>
                <div id="coin-display" style="font-size: 14px; color: #ff0; margin-top: 5px;">üí∞ 0</div>
            </div>
            
            <!-- Right: Pause/Quit -->
            <div style="flex: 1; display: flex; justify-content: flex-end; gap: 8px;">
                <button onclick="Game.pauseGame()" style="background: rgba(0,20,0,0.8); border: 1px solid var(--neon-green); color: var(--neon-green); padding: 6px 10px; font-family: 'Courier New', monospace; font-size: 11px; cursor: pointer;">‚è∏</button>
                <button onclick="Game.returnToMenu()" style="background: rgba(20,0,0,0.8); border: 1px solid #f00; color: #f00; padding: 6px 10px; font-family: 'Courier New', monospace; font-size: 11px; cursor: pointer;">‚úï</button>
            </div>
        </div>
    </div>

    <!-- Main Menu -->
    <div id="main-menu" class="screen">
        <h1>PROTOCOL:<br>OVERRIDE</h1>
        <p>SECURE THE SYSTEM. ELIMINATE BUGS.</p>
        <div class="level-grid" id="level-select">
            <!-- Generated by JS -->
        </div>
        <div style="margin-top: 15px; display: flex; gap: 10px; justify-content: center;">
            <button class="btn shop-btn" onclick="Game.openShop()" style="background: linear-gradient(135deg, #ff0 0%, #f80 100%); color: #000;">üõí SHOP</button>
        </div>
        <div style="margin-top: 10px; font-size: 14px; color: #ff0;">üí∞ <span id="menu-coins">0</span> COINS</div>
        <div style="margin-top: 5px; font-size: 12px; color: #888;">TAP TO SELECT DAY</div>
    </div>

    <!-- Shop Screen -->
    <div id="shop-screen" class="screen hidden">
        <div style="width: 95%; max-width: 500px; height: 90%; display: flex; flex-direction: column;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h2 style="margin: 0; font-size: 28px; color: var(--neon-green);">üõí SKIN SHOP</h2>
                <div style="font-size: 20px; color: #ff0;">üí∞ <span id="shop-coins">0</span></div>
            </div>
            
            <div id="skin-grid" style="flex: 1; overflow-y: auto; display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; padding: 5px;">
                <!-- Skins generated by JS -->
            </div>
            
            <button class="btn" onclick="Game.closeShop()" style="margin-top: 15px;">‚Üê BACK TO MENU</button>
        </div>
    </div>

    <!-- Hack Modal -->
    <div id="hack-modal" class="hidden">
        <div style="width:100%; text-align:right; font-size:12px; color:var(--neon-red);">Sys._Override</div>
        <div id="timer-bar"><div id="timer-fill"></div></div>
        <div id="hack-question" class="hack-question">2 + 2 = ?</div>
        <div id="hack-options" class="hack-options">
            <!-- Buttons generated by JS -->
        </div>
    </div>

    <!-- Pause Screen -->
    <div id="pause-screen" class="screen hidden">
        <h1>‚è∏ PAUSED</h1>
        <p>System on hold...</p>
        <button class="btn" onclick="Game.resumeGame()">RESUME</button>
        <button class="btn" style="margin-top: 10px;" onclick="Game.returnToMenu()">QUIT TO MENU</button>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="screen hidden">
        <h1 id="go-title">SYSTEM FAILURE</h1>
        <p id="go-score">SURVIVED: 00:00</p>
        <button class="btn" onclick="Game.returnToMenu()">REBOOT SYSTEM</button>
    </div>
</div>

<!-- HUD Controls are now integrated into game-ui above -->


<script>
/**
 * PROTOCOL: OVERRIDE
 * Single File HTML5 Game
 */

/* --- CONFIG & DATA --- */
const CONFIG = {
    FPS_TARGET: 60,
    PLAYER_SPEED: 4,
    PLAYER_SIZE: 15,
    BULLET_SPEED: 12,
    ENEMY_BASE_SPEED: 2,
    ENEMY_SPAWN_RATE: 40, // Balanced - not too easy, not too hard
    ENEMIES_PER_WAVE: 3, // Spawn 3 at once for good challenge
    DAY_DURATION: 120, // seconds
    SLOW_MO_SCALE: 0.1,
    LEVELS: [
        { bg: '#050505', neon: '#0f0', enemyColor: '#f00', enemySize: 12, theme: 'Basic Virus' },
        { bg: '#050005', neon: '#f0f', enemyColor: '#f0f', enemySize: 10, theme: 'Mutant Strain' },
        { bg: '#000505', neon: '#0ff', enemyColor: '#0ff', enemySize: 14, theme: 'Aqua Infection' },
        { bg: '#050500', neon: '#ff0', enemyColor: '#ff0', enemySize: 11, theme: 'Solar Bug' },
        { bg: '#050000', neon: '#f00', enemyColor: '#f44', enemySize: 13, theme: 'Red Death' },
        { bg: '#000005', neon: '#00f', enemyColor: '#00f', enemySize: 9, theme: 'Deep Core' },
        { bg: '#101010', neon: '#fff', enemyColor: '#888', enemySize: 15, theme: 'Ghost Protocol' },
        { bg: '#001000', neon: '#0f0', enemyColor: '#0f0', enemySize: 12, theme: 'Matrix Breach' },
        { bg: '#100010', neon: '#f0f', enemyColor: '#f0f', enemySize: 10, theme: 'Quantum Bug' },
        { bg: '#000', neon: '#f00', enemyColor: '#fff', enemySize: 16, theme: 'Final Boss' }
    ]
};

const TRIVIA_DB = [
    { q: "12 + 15 = ?", a: ["27", "25", "37", "22"], correct: 0 },
    { q: "Binary 101 = ?", a: ["5", "3", "6", "10"], correct: 0 },
    { q: "Hex #FF0000 is?", a: ["Red", "Green", "Blue", "White"], correct: 0 },
    { q: "8 * 7 = ?", a: ["56", "54", "64", "48"], correct: 0 },
    { q: "100 / 4 = ?", a: ["25", "20", "24", "10"], correct: 0 },
    { q: "First prime number?", a: ["2", "1", "3", "0"], correct: 0 },
    { q: "Pi is approx?", a: ["3.14", "3.41", "2.14", "3.00"], correct: 0 },
    { q: "3 squared?", a: ["9", "6", "27", "33"], correct: 0 },
    { q: "Bits in a Byte?", a: ["8", "16", "4", "32"], correct: 0 },
    { q: "HTML stands for?", a: ["HyperText", "HighText", "HomeTool", "HyperTech"], correct: 0 },
    { q: "50% of 80?", a: ["40", "20", "50", "30"], correct: 0 },
    { q: "Square root of 64?", a: ["8", "6", "4", "16"], correct: 0 },
    { q: "2^3 = ?", a: ["8", "6", "9", "4"], correct: 0 },
    { q: "Opposite of TRUE?", a: ["FALSE", "NULL", "UNDEFINED", "YES"], correct: 0 },
    { q: "20 - 7 = ?", a: ["13", "11", "12", "14"], correct: 0 }
];

/**
 * SKINS CONFIGURATION
 * Each skin defines appearance colors and unlock requirements.
 * Colors: head (skin tone), body (shirt), arms (skin/sleeves), legs (pants)
 */
const SKINS_CONFIG = [
    {
        id: 'skin_default',
        name: 'Default Agent',
        price: 0,
        isDefault: true,
        colors: {
            head: '#ffdbac',
            body: '#0f0',
            arms: '#ffdbac',
            legs: '#060'
        },
        description: 'Standard issue security drone operator'
    },
    {
        id: 'skin_ninja',
        name: 'Shadow Ninja',
        price: 50,
        isDefault: false,
        colors: {
            head: '#333',
            body: '#111',
            arms: '#333',
            legs: '#000'
        },
        description: 'Silent and deadly. Blends into shadows.'
    },
    {
        id: 'skin_cyber',
        name: 'Cyber Punk',
        price: 100,
        isDefault: false,
        colors: {
            head: '#0ff',
            body: '#f0f',
            arms: '#0ff',
            legs: '#808'
        },
        description: 'Neon-infused street hacker aesthetic'
    },
    {
        id: 'skin_fire',
        name: 'Flame Walker',
        price: 150,
        isDefault: false,
        colors: {
            head: '#f80',
            body: '#f00',
            arms: '#f80',
            legs: '#800'
        },
        description: 'Burns with the fury of a thousand suns'
    },
    {
        id: 'skin_ice',
        name: 'Frost Byte',
        price: 150,
        isDefault: false,
        colors: {
            head: '#aef',
            body: '#08f',
            arms: '#aef',
            legs: '#048'
        },
        description: 'Cool as ice, cold as code'
    },
    {
        id: 'skin_gold',
        name: 'Golden Elite',
        price: 300,
        isDefault: false,
        colors: {
            head: '#fc0',
            body: '#ff0',
            arms: '#fc0',
            legs: '#a80'
        },
        description: 'For the truly wealthy operators'
    },
    {
        id: 'skin_ghost',
        name: 'Ghost Protocol',
        price: 400,
        isDefault: false,
        colors: {
            head: 'rgba(255,255,255,0.7)',
            body: 'rgba(200,200,255,0.5)',
            arms: 'rgba(255,255,255,0.7)',
            legs: 'rgba(150,150,200,0.5)'
        },
        description: 'Ethereal presence. Neither here nor there.'
    },
    {
        id: 'skin_rainbow',
        name: 'RGB Master',
        price: 500,
        isDefault: false,
        colors: {
            head: '#f00',
            body: '#0f0',
            arms: '#00f',
            legs: '#ff0'
        },
        description: 'Ultimate gamer skin. Maximum RGB.'
    }
];

/* --- UTILS --- */
const $ = (id) => document.getElementById(id);
const Rand = (min, max) => Math.random() * (max - min) + min;
const Dist = (x1, y1, x2, y2) => Math.sqrt((x2-x1)**2 + (y2-y1)**2);

class Pool {
    constructor(createFn, initialSize=20) {
        this.createFn = createFn;
        this.items = [];
        this.active = [];
        for(let i=0; i<initialSize; i++) this.items.push(this.createFn());
    }
    get() {
        let item = this.items.length > 0 ? this.items.pop() : this.createFn();
        item.active = true;
        this.active.push(item);
        return item;
    }
    release(item) {
        item.active = false;
        const idx = this.active.indexOf(item);
        if(idx > -1) this.active.splice(idx, 1);
        this.items.push(item);
    }
    update(dt, ctx) {
        for(let i=this.active.length-1; i>=0; i--) {
            if(this.active[i].update(dt)) {
                this.active[i].draw(ctx);
            } else {
                this.release(this.active[i]);
            }
        }
    }
}

/* --- GAME ENTITIES --- */
class Particle {
    constructor() { 
        this.reset(0,0);
    }
    reset(x, y, color='#fff') {
        this.x = x; this.y = y;
        this.vx = Rand(-3, 3);
        this.vy = Rand(-3, 3);
        this.life = 1.0;
        this.color = color;
        this.size = Rand(2, 4);
        return this;
    }
    update(dt) {
        this.x += this.vx * dt * 60;
        this.y += this.vy * dt * 60;
        this.life -= dt * 2;
        return this.life > 0;
    }
    draw(ctx) {
        Game.ctx.globalAlpha = this.life;
        Game.ctx.fillStyle = this.color;
        Game.ctx.fillRect(this.x, this.y, this.size, this.size);
        Game.ctx.globalAlpha = 1;
    }
}

class XPGem {
    constructor() { this.reset(0, 0); }
    reset(x, y) {
        this.x = x;
        this.y = y;
        this.active = true;
        this.size = 6;
        this.rotation = Math.random() * Math.PI * 2;
        this.pulsePhase = Math.random() * Math.PI * 2;
        return this;
    }
    update(dt) {
        // Pulse animation
        this.pulsePhase += dt * 5;
        this.rotation += dt * 2;
        
        // Check if player is close enough to collect
        if(Game.player && Game.player.active) {
            let dist = Dist(this.x, this.y, Game.player.x, Game.player.y);
            if(dist < 30) {
                // Move towards player
                let dx = Game.player.x - this.x;
                let dy = Game.player.y - this.y;
                this.x += (dx / dist) * 8 * dt * 60;
                this.y += (dy / dist) * 8 * dt * 60;
                
                if(dist < 15) {
                    Game.addScore(1);
                    Game.spawnParticles(this.x, this.y, '#0ff');
                    return false; // Collected
                }
            }
        }
        return true;
    }
    draw(ctx) {
        let pulseSize = this.size + Math.sin(this.pulsePhase) * 2;
        
        Game.ctx.save();
        Game.ctx.translate(this.x, this.y);
        Game.ctx.rotate(this.rotation);
        
        // Outer glow
        Game.ctx.shadowBlur = 15;
        Game.ctx.shadowColor = '#0ff';
        
        // Diamond shape
        Game.ctx.fillStyle = '#0ff';
        Game.ctx.beginPath();
        Game.ctx.moveTo(0, -pulseSize);
        Game.ctx.lineTo(pulseSize, 0);
        Game.ctx.lineTo(0, pulseSize);
        Game.ctx.lineTo(-pulseSize, 0);
        Game.ctx.closePath();
        Game.ctx.fill();
        
        // Inner highlight
        Game.ctx.fillStyle = '#fff';
        Game.ctx.beginPath();
        Game.ctx.moveTo(0, -pulseSize * 0.5);
        Game.ctx.lineTo(pulseSize * 0.5, 0);
        Game.ctx.lineTo(0, pulseSize * 0.5);
        Game.ctx.lineTo(-pulseSize * 0.5, 0);
        Game.ctx.closePath();
        Game.ctx.fill();
        
        Game.ctx.restore();
    }
}

class Coin {
    constructor() { this.reset(0, 0); }
    reset(x, y) {
        this.x = x;
        this.y = y;
        this.active = true;
        this.size = 8;
        this.rotation = 0;
        this.pulsePhase = Math.random() * Math.PI * 2;
        this.vx = (Math.random() - 0.5) * 3;
        this.vy = (Math.random() - 0.5) * 3 - 2; // Initial upward velocity
        this.gravity = 0.2;
        return this;
    }
    update(dt) {
        // Physics
        this.vy += this.gravity;
        this.x += this.vx * dt * 60;
        this.y += this.vy * dt * 60;
        this.vx *= 0.98; // Friction
        this.vy *= 0.98;
        
        // Animation
        this.rotation += dt * 4;
        this.pulsePhase += dt * 5;
        
        // Check if player is close enough to collect
        if(Game.player && Game.player.active) {
            let dist = Dist(this.x, this.y, Game.player.x, Game.player.y);
            
            // Magnet effect - attract from much farther away
            let attractRange = Game.magnetActive ? 500 : 40;
            let attractSpeed = Game.magnetActive ? 15 : 10;
            
            if(dist < attractRange) {
                // Move towards player
                let dx = Game.player.x - this.x;
                let dy = Game.player.y - this.y;
                this.x += (dx / dist) * attractSpeed * dt * 60;
                this.y += (dy / dist) * attractSpeed * dt * 60;
                
                if(dist < 20) {
                    Game.addCoins(1);
                    Game.spawnParticles(this.x, this.y, '#ff0');
                    return false; // Collected
                }
            }
        }
        return true;
    }
    draw(ctx) {
        let pulseSize = this.size + Math.sin(this.pulsePhase) * 1.5;
        
        Game.ctx.save();
        Game.ctx.translate(this.x, this.y);
        Game.ctx.rotate(this.rotation);
        
        // Outer glow
        Game.ctx.shadowBlur = 15;
        Game.ctx.shadowColor = '#ff0';
        
        // Coin circle
        Game.ctx.fillStyle = '#ff0';
        Game.ctx.beginPath();
        Game.ctx.arc(0, 0, pulseSize, 0, Math.PI * 2);
        Game.ctx.fill();
        
        // Inner highlight
        Game.ctx.fillStyle = '#fff';
        Game.ctx.beginPath();
        Game.ctx.arc(-pulseSize * 0.2, -pulseSize * 0.2, pulseSize * 0.4, 0, Math.PI * 2);
        Game.ctx.fill();
        
        // Dollar sign
        Game.ctx.fillStyle = '#f80';
        Game.ctx.font = 'bold ' + (pulseSize * 1.2) + 'px Arial';
        Game.ctx.textAlign = 'center';
        Game.ctx.textBaseline = 'middle';
        Game.ctx.fillText('$', 0, 0);
        
        Game.ctx.restore();
    }
}

class Magnet {
    constructor() { this.reset(0, 0); }
    reset(x, y) {
        this.x = x;
        this.y = y;
        this.active = true;
        this.size = 12;
        this.pulsePhase = Math.random() * Math.PI * 2;
        this.rotation = 0;
        return this;
    }
    update(dt) {
        this.pulsePhase += dt * 4;
        this.rotation += dt * 2;
        
        // Check if player is close enough to collect
        if(Game.player && Game.player.active) {
            let dist = Dist(this.x, this.y, Game.player.x, Game.player.y);
            if(dist < 30) {
                // Activate magnetic field!
                Game.magnetActive = true;
                Game.magnetTimer = 8; // 8 seconds of magnetic attraction
                Game.spawnParticles(this.x, this.y, '#f0f');
                Game.createFloater('üß≤ MAGNET!', this.x, this.y - 20);
                return false; // Collected
            }
        }
        return true;
    }
    draw(ctx) {
        let pulseSize = this.size + Math.sin(this.pulsePhase) * 2;
        
        Game.ctx.save();
        Game.ctx.translate(this.x, this.y);
        Game.ctx.rotate(this.rotation);
        
        // Outer glow
        Game.ctx.shadowBlur = 20;
        Game.ctx.shadowColor = '#f0f';
        
        // Horseshoe shape (simplified U-magnet)
        Game.ctx.strokeStyle = '#f00';
        Game.ctx.lineWidth = 4;
        Game.ctx.lineCap = 'round';
        
        // Left pole (red)
        Game.ctx.beginPath();
        Game.ctx.moveTo(-pulseSize * 0.6, -pulseSize);
        Game.ctx.lineTo(-pulseSize * 0.6, pulseSize * 0.3);
        Game.ctx.stroke();
        
        // Right pole (blue)
        Game.ctx.strokeStyle = '#00f';
        Game.ctx.beginPath();
        Game.ctx.moveTo(pulseSize * 0.6, -pulseSize);
        Game.ctx.lineTo(pulseSize * 0.6, pulseSize * 0.3);
        Game.ctx.stroke();
        
        // U curve
        Game.ctx.strokeStyle = '#888';
        Game.ctx.beginPath();
        Game.ctx.arc(0, pulseSize * 0.3, pulseSize * 0.6, 0, Math.PI);
        Game.ctx.stroke();
        
        // Inner field lines
        Game.ctx.strokeStyle = 'rgba(255, 0, 255, 0.5)';
        Game.ctx.lineWidth = 1;
        for(let i = 0; i < 3; i++) {
            let offset = Math.sin(this.pulsePhase + i) * 3;
            Game.ctx.beginPath();
            Game.ctx.arc(0, -pulseSize * 0.3 + offset, pulseSize * 0.3, 0, Math.PI, true);
            Game.ctx.stroke();
        }
        
        Game.ctx.restore();
    }
}

class Bullet {
    constructor() { this.reset(0,0,0,0); }
    reset(x, y, dx, dy, isOP=false) {
        this.x = x; this.y = y;
        this.dx = dx; this.dy = dy;
        this.isOP = isOP; // Overpowered
        this.active = true;
        this.size = isOP ? 8 : 4;
        this.damage = isOP ? 50 : 10;
        return this;
    }
    update(dt) {
        this.x += this.dx * CONFIG.BULLET_SPEED * dt * 60;
        this.y += this.dy * CONFIG.BULLET_SPEED * dt * 60;
        return (this.x > 0 && this.x < Game.canvas.width && this.y > 0 && this.y < Game.canvas.height);
    }
    draw(ctx) {
        Game.ctx.shadowBlur = 10;
        Game.ctx.shadowColor = this.isOP ? '#f0f' : '#0f0';
        Game.ctx.fillStyle = this.isOP ? '#fff' : '#0f0';
        Game.ctx.beginPath();
        Game.ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
        Game.ctx.fill();
        Game.ctx.shadowBlur = 0;
    }
}

class Enemy {
    constructor() { this.reset(); }
    reset() {
        this.active = true;
        
        // Random enemy type (0=Virus, 1=Bug, 2=Worm, 3=Blob)
        this.type = Math.floor(Math.random() * 4);
        
        // Spawn from random edge (0=top, 1=right, 2=bottom, 3=left)
        let edge = Math.floor(Math.random() * 4);
        switch(edge) {
            case 0: // Top
                this.x = Math.random() * Game.canvas.width;
                this.y = -20;
                break;
            case 1: // Right
                this.x = Game.canvas.width + 20;
                this.y = Math.random() * Game.canvas.height;
                break;
            case 2: // Bottom
                this.x = Math.random() * Game.canvas.width;
                this.y = Game.canvas.height + 20;
                break;
            case 3: // Left
                this.x = -20;
                this.y = Math.random() * Game.canvas.height;
                break;
        }
        
        // Level-specific properties
        let levelData = CONFIG.LEVELS[Game.level - 1];
        this.hp = 10 + (Game.level * 5);
        this.maxHp = this.hp;
        this.baseSize = levelData.enemySize;
        this.size = this.baseSize;
        this.color = levelData.enemyColor;
        this.speed = CONFIG.ENEMY_BASE_SPEED + (Game.level * 0.15); // Moderate scaling
        this.animPhase = Math.random() * Math.PI * 2;
        return this;
    }
    update(dt) {
        if(!Game.player.active) return true;
        
        this.animPhase += dt * 3;
        
        let dx = Game.player.x - this.x;
        let dy = Game.player.y - this.y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        
        if(dist < 5) return true; // Touch player
        
        // Different movement per type
        if(this.type === 2) { // Worm - zigzag movement
            let perpX = -dy / dist;
            let perpY = dx / dist;
            let zigzag = Math.sin(this.animPhase * 2) * 2;
            this.x += ((dx/dist) + perpX * zigzag) * this.speed * dt * 60;
            this.y += ((dy/dist) + perpY * zigzag) * this.speed * dt * 60;
        } else if(this.type === 3) { // Blob - slower but tankier
            this.x += (dx/dist) * this.speed * 0.7 * dt * 60;
            this.y += (dy/dist) * this.speed * 0.7 * dt * 60;
        } else { // Virus & Bug - direct movement
            this.x += (dx/dist) * this.speed * dt * 60;
            this.y += (dy/dist) * this.speed * dt * 60;
        }
        return true;
    }
    draw(ctx) {
        Game.ctx.save();
        
        // Different visuals per enemy type
        switch(this.type) {
            case 0: // Virus - spiky corona
                this.drawVirus();
                break;
            case 1: // Bug - hexagonal with legs
                this.drawBug();
                break;
            case 2: // Worm - segmented
                this.drawWorm();
                break;
            case 3: // Blob - amorphous pulsing
                this.drawBlob();
                break;
        }
        
        Game.ctx.restore();
    }
    
    drawVirus() {
        // Outer glow
        Game.ctx.shadowBlur = 10;
        Game.ctx.shadowColor = this.color;
        
        // Central body
        Game.ctx.fillStyle = this.color;
        Game.ctx.beginPath();
        Game.ctx.arc(this.x, this.y, this.size * 0.7, 0, Math.PI * 2);
        Game.ctx.fill();
        
        // Spikes around the body (virus-like)
        let spikeCount = 8;
        let time = Date.now() * 0.001;
        for(let i = 0; i < spikeCount; i++) {
            let angle = (i / spikeCount) * Math.PI * 2 + time;
            let spikeLength = this.size * 0.8;
            
            let x1 = this.x + Math.cos(angle) * this.size * 0.5;
            let y1 = this.y + Math.sin(angle) * this.size * 0.5;
            let x2 = this.x + Math.cos(angle) * spikeLength;
            let y2 = this.y + Math.sin(angle) * spikeLength;
            
            Game.ctx.strokeStyle = this.color;
            Game.ctx.lineWidth = 2;
            Game.ctx.beginPath();
            Game.ctx.moveTo(x1, y1);
            Game.ctx.lineTo(x2, y2);
            Game.ctx.stroke();
            
            Game.ctx.fillStyle = '#f00';
            Game.ctx.beginPath();
            Game.ctx.arc(x2, y2, 2, 0, Math.PI * 2);
            Game.ctx.fill();
        }
        
        // Inner core
        Game.ctx.fillStyle = '#800';
        Game.ctx.beginPath();
        Game.ctx.arc(this.x, this.y, this.size * 0.3, 0, Math.PI * 2);
        Game.ctx.fill();
    }
    
    drawBug() {
        // Hexagonal body
        Game.ctx.shadowBlur = 8;
        Game.ctx.shadowColor = this.color;
        Game.ctx.fillStyle = this.color;
        Game.ctx.beginPath();
        for(let i = 0; i < 6; i++) {
            let angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
            let x = this.x + Math.cos(angle) * this.size;
            let y = this.y + Math.sin(angle) * this.size;
            if(i === 0) Game.ctx.moveTo(x, y);
            else Game.ctx.lineTo(x, y);
        }
        Game.ctx.closePath();
        Game.ctx.fill();
        
        // Legs (4 on each side)
        Game.ctx.strokeStyle = this.color;
        Game.ctx.lineWidth = 1.5;
        for(let i = 0; i < 4; i++) {
            let side = i < 2 ? -1 : 1;
            let offset = (i % 2) * this.size * 0.5;
            let legX = this.x + side * this.size;
            let legY = this.y - this.size * 0.3 + offset;
            Game.ctx.beginPath();
            Game.ctx.moveTo(this.x + side * this.size * 0.5, legY);
            Game.ctx.lineTo(legX, legY);
            Game.ctx.stroke();
        }
        
        // Eyes
        Game.ctx.fillStyle = '#fff';
        Game.ctx.beginPath();
        Game.ctx.arc(this.x - this.size * 0.3, this.y - this.size * 0.2, 2, 0, Math.PI * 2);
        Game.ctx.arc(this.x + this.size * 0.3, this.y - this.size * 0.2, 2, 0, Math.PI * 2);
        Game.ctx.fill();
    }
    
    drawWorm() {
        // Segmented body
        Game.ctx.shadowBlur = 6;
        Game.ctx.shadowColor = this.color;
        
        let segments = 5;
        for(let i = 0; i < segments; i++) {
            let segSize = this.size * (1 - i * 0.15);
            let offsetX = Math.cos(this.animPhase + i) * 3;
            let offsetY = Math.sin(this.animPhase + i) * 3;
            
            Game.ctx.fillStyle = this.color;
            Game.ctx.globalAlpha = 1 - (i * 0.1);
            Game.ctx.beginPath();
            Game.ctx.arc(this.x + offsetX, this.y + offsetY, segSize, 0, Math.PI * 2);
            Game.ctx.fill();
        }
        Game.ctx.globalAlpha = 1;
        
        // Head stripe
        Game.ctx.strokeStyle = '#fff';
        Game.ctx.lineWidth = 2;
        Game.ctx.beginPath();
        Game.ctx.arc(this.x, this.y, this.size, Math.PI * 0.3, Math.PI * 0.7);
        Game.ctx.stroke();
    }
    
    drawBlob() {
        // Amorphous pulsing shape
        let pulseSize = this.size + Math.sin(this.animPhase) * 3;
        
        Game.ctx.shadowBlur = 12;
        Game.ctx.shadowColor = this.color;
        
        // Irregular blob shape
        Game.ctx.fillStyle = this.color;
        Game.ctx.beginPath();
        for(let i = 0; i < 12; i++) {
            let angle = (i / 12) * Math.PI * 2;
            let variance = Math.sin(this.animPhase + i) * 0.3;
            let r = pulseSize * (0.8 + variance);
            let x = this.x + Math.cos(angle) * r;
            let y = this.y + Math.sin(angle) * r;
            if(i === 0) Game.ctx.moveTo(x, y);
            else Game.ctx.lineTo(x, y);
        }
        Game.ctx.closePath();
        Game.ctx.fill();
        
        // Inner goop
        Game.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        Game.ctx.beginPath();
        Game.ctx.arc(this.x, this.y, pulseSize * 0.4, 0, Math.PI * 2);
        Game.ctx.fill();
    }
    takeDamage(dmg) {
        this.hp -= dmg;
        Game.shake = 2;
        
        // Blobs take less damage
        if(this.type === 3) {
            this.hp += dmg * 0.3;
        }
        
        if(this.hp <= 0) {
            // Spawn XP gem at death location
            let gem = Game.gems.get();
            gem.reset(this.x, this.y);
            
            // 30% chance to drop a coin
            if(Math.random() < 0.3) {
                let coin = Game.coins.get();
                coin.reset(this.x, this.y);
            }
            
            // 5% chance to drop a magnet powerup
            if(Math.random() < 0.05) {
                let magnet = Game.magnets.get();
                magnet.reset(this.x, this.y);
            }
            
            this.active = false;
            Game.spawnParticles(this.x, this.y, '#f00');
            Game.addScore(1);
            return true; // Dead
        }
        return false;
    }
}

class Player {
    constructor() {
        this.x = 0;
        this.y = 0;
        this.active = true;
        this.shootTimer = 0;
        this.opTimer = 0;
        this.hp = 100;
        this.hasOpWeapon = false;
        this.walkPhase = 0;
        this.currentSkin = 'default';
    }
    reset() {
        this.x = Game.canvas.width/2; 
        this.y = Game.canvas.height/2;
        this.active = true;
        this.hp = 100;
        this.hasOpWeapon = false;
        this.opTimer = 0;
        this.walkPhase = 0;
    }
    update(dt) {
        // Movement
        this.x += Input.x * CONFIG.PLAYER_SPEED * dt * 60;
        this.y += Input.y * CONFIG.PLAYER_SPEED * dt * 60;

        // Bounds
        this.x = Math.max(15, Math.min(Game.canvas.width - 15, this.x));
        this.y = Math.max(15, Math.min(Game.canvas.height - 15, this.y));
        
        // Walking animation
        if(Input.x !== 0 || Input.y !== 0) {
            this.walkPhase += dt * 8;
        }

        // OP Weapon Timer
        if(this.hasOpWeapon) {
            this.opTimer -= dt;
            if(this.opTimer <= 0) this.hasOpWeapon = false;
        }

        // Shooting
        this.shootTimer -= dt;
        if(this.shootTimer <= 0 && Game.enemies.active.length > 0) {
            this.shoot();
            this.shootTimer = this.hasOpWeapon ? 0.05 : 0.3; // Rapid fire if OP
        }

        // Enemy Collision - Take damage
        Game.enemies.active.forEach(e => {
            if(Dist(this.x, this.y, e.x, e.y) < 20) {
                this.hp -= 10 * dt;
                Game.shake = 5;
                if(this.hp <= 0) {
                    this.active = false;
                    Game.gameOver();
                }
            }
        });
    }
    
    shoot() {
        // Find nearest enemy
        let nearest = null;
        let minDist = Infinity;
        Game.enemies.active.forEach(e => {
            let d = Dist(this.x, this.y, e.x, e.y);
            if(d < minDist) {
                minDist = d;
                nearest = e;
            }
        });

        if(nearest) {
            let dx = nearest.x - this.x;
            let dy = nearest.y - this.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            let b = Game.bullets.get();
            b.reset(this.x, this.y, dx/dist, dy/dist, this.hasOpWeapon);
            
            // Triple shot if OP
            if(this.hasOpWeapon) {
                let angle = Math.atan2(dy, dx);
                let b2 = Game.bullets.get();
                b2.reset(this.x, this.y, Math.cos(angle+0.2), Math.sin(angle+0.2), true);
                let b3 = Game.bullets.get();
                b3.reset(this.x, this.y, Math.cos(angle-0.2), Math.sin(angle-0.2), true);
            }
        }
    }
    
    draw(ctx) {
        // Get skin colors (future: from skin config)
        let skinColor = this.getSkinColors();
        
        Game.ctx.save();
        
        // Character center is at this.x, this.y
        let bodySize = 12;
        let legSwing = Math.sin(this.walkPhase) * 3;
        
        // Legs
        Game.ctx.strokeStyle = skinColor.legs;
        Game.ctx.lineWidth = 3;
        Game.ctx.lineCap = 'round';
        
        // Left leg
        Game.ctx.beginPath();
        Game.ctx.moveTo(this.x - 3, this.y + bodySize/2);
        Game.ctx.lineTo(this.x - 3 - legSwing, this.y + bodySize + 8);
        Game.ctx.stroke();
        
        // Right leg
        Game.ctx.beginPath();
        Game.ctx.moveTo(this.x + 3, this.y + bodySize/2);
        Game.ctx.lineTo(this.x + 3 + legSwing, this.y + bodySize + 8);
        Game.ctx.stroke();
        
        // Body
        Game.ctx.fillStyle = skinColor.body;
        Game.ctx.fillRect(this.x - bodySize/2, this.y - bodySize/2, bodySize, bodySize);
        
        // Arms
        Game.ctx.strokeStyle = skinColor.arms;
        Game.ctx.lineWidth = 2;
        
        // Left arm
        Game.ctx.beginPath();
        Game.ctx.moveTo(this.x - bodySize/2, this.y - bodySize/4);
        Game.ctx.lineTo(this.x - bodySize - 4, this.y + legSwing * 0.5);
        Game.ctx.stroke();
        
        // Right arm (holding weapon)
        Game.ctx.beginPath();
        Game.ctx.moveTo(this.x + bodySize/2, this.y - bodySize/4);
        Game.ctx.lineTo(this.x + bodySize + 6, this.y - legSwing * 0.5);
        Game.ctx.stroke();
        
        // Weapon indicator
        Game.ctx.fillStyle = this.hasOpWeapon ? '#fff' : '#0f0';
        Game.ctx.beginPath();
        Game.ctx.arc(this.x + bodySize + 6, this.y - legSwing * 0.5, 2, 0, Math.PI * 2);
        Game.ctx.fill();
        
        // Head
        Game.ctx.fillStyle = skinColor.head;
        Game.ctx.beginPath();
        Game.ctx.arc(this.x, this.y - bodySize - 3, 6, 0, Math.PI * 2);
        Game.ctx.fill();
        
        // Eyes
        Game.ctx.fillStyle = '#fff';
        Game.ctx.beginPath();
        Game.ctx.arc(this.x - 2, this.y - bodySize - 3, 1.5, 0, Math.PI * 2);
        Game.ctx.arc(this.x + 2, this.y - bodySize - 3, 1.5, 0, Math.PI * 2);
        Game.ctx.fill();
        
        // OP Aura
        if(this.hasOpWeapon) {
            Game.ctx.strokeStyle = `rgba(255, 255, 255, ${Math.random() * 0.5 + 0.3})`;
            Game.ctx.lineWidth = 2;
            Game.ctx.beginPath();
            Game.ctx.arc(this.x, this.y, 25, 0, Math.PI * 2);
            Game.ctx.stroke();
        }
        
        Game.ctx.restore();
    }
    
    getSkinColors() {
        // Get skin colors from SKINS_CONFIG based on equipped skin
        const equippedId = Game.equippedSkinId || 'skin_default';
        const skin = SKINS_CONFIG.find(s => s.id === equippedId);
        if(skin && skin.colors) {
            return skin.colors;
        }
        // Fallback to default
        return SKINS_CONFIG[0].colors;
    }
}


/* --- INPUT MANAGER --- */
const Input = {
    x: 0, y: 0,
    active: false,
    originX: 0, originY: 0,
    
    init() {
        const zone = $('game-container');
        
        const start = (x, y) => {
            if(Game.state !== 'PLAYING') return;
            this.active = true;
            this.originX = window.innerWidth / 2;
            this.originY = window.innerHeight - 100; // Fixed joystick pos
            this.update(x, y);
        };
        
        const move = (x, y) => {
            if(!this.active) return;
            this.update(x, y);
        };
        
        const end = () => {
            this.active = false;
            this.x = 0; this.y = 0;
            $('joystick-zone').style.transform = `translateX(-50%) scale(1)`;
        };

        // Touch
        zone.addEventListener('touchstart', e => start(e.touches[0].clientX, e.touches[0].clientY));
        zone.addEventListener('touchmove', e => move(e.touches[0].clientX, e.touches[0].clientY));
        zone.addEventListener('touchend', end);

        // Mouse
        zone.addEventListener('mousedown', e => start(e.clientX, e.clientY));
        zone.addEventListener('mousemove', e => move(e.clientX, e.clientY));
        zone.addEventListener('mouseup', end);
    }
    ,
    update(cx, cy) {
        const maxDist = 50;
        let dx = cx - this.originX;
        let dy = cy - this.originY;
        let dist = Math.sqrt(dx*dx + dy*dy);
        
        if(dist > maxDist) {
            dx = (dx/dist) * maxDist;
            dy = (dy/dist) * maxDist;
        }
        
        // Visual feedback
        const jx = (dx / maxDist);
        const jy = (dy / maxDist);
        this.x = jx;
        this.y = jy;

        // Visual
        const zone = $('joystick-zone');
        // Actually keep the zone fixed, just move a virtual thumb if we had one
        // For now, simpler: scale the zone slightly to show activity
        zone.style.transform = `translateX(-50%) translate(${dx*0.2}px, ${dy*0.2}px)`;
    }
};

/* --- GAME ENGINE --- */
const Game = {
    canvas: null,
    ctx: null,
    state: 'MENU', // MENU, PLAYING, PAUSED, HACK, OVER
    lastTime: 0,
    level: 1,
    maxLevel: 1,
    score: 0,
    xp: 0,
    maxXp: 10,
    time: 0,
    shake: 0,
    
    // Pools - will be initialized in init()
    player: null,
    enemies: null,
    bullets: null,
    particles: null,
    gems: null,
    coins: null,
    magnets: null,
    
    magnetActive: false, // Magnet powerup active
    magnetTimer: 0,
    totalCoins: 0, // Persistent currency
    ownedSkins: ['skin_default'], // Array of owned skin IDs
    equippedSkinId: 'skin_default', // Currently equipped skin
    waveTimer: 0, // For spawning waves

    init() {
        // Initialize canvas and context
        this.canvas = $('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        
        // Initialize pools
        this.player = new Player();
        this.enemies = new Pool(() => new Enemy(), 50);
        this.bullets = new Pool(() => new Bullet(), 50);
        this.particles = new Pool(() => new Particle(), 50);
        this.gems = new Pool(() => new XPGem(), 30);
        this.coins = new Pool(() => new Coin(), 20);
        this.magnets = new Pool(() => new Magnet(), 5);
        
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        Input.init();
        
        // Initialize player position now that canvas is sized
        this.player.x = this.canvas.width / 2;
        this.player.y = this.canvas.height / 2;
        
        // Load save
        const save = localStorage.getItem('protocol_override_save');
        if(save) {
            const data = JSON.parse(save);
            this.maxLevel = data.maxDayUnlocked || 1;
            this.totalCoins = data.totalCoins || 0;
            this.ownedSkins = data.ownedSkins || ['skin_default'];
            this.equippedSkinId = data.equippedSkinId || 'skin_default';
        }

        this.renderMenu();
        requestAnimationFrame(t => this.loop(t));
    },

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    },

    startLevel(lvl) {
        this.level = lvl;
        this.score = 0;
        this.xp = 0;
        this.maxXp = 10 + (lvl * 5);
        this.time = CONFIG.DAY_DURATION;
        this.state = 'PLAYING';
        
        // Visual setup
        let levelData = CONFIG.LEVELS[lvl-1];
        document.documentElement.style.setProperty('--bg-color', levelData.bg);
        document.documentElement.style.setProperty('--neon-green', levelData.neon);
        
        // Reset Entitites
        this.player.reset();
        this.enemies.active = [];
        this.bullets.active = [];
        this.gems.active = [];
        this.coins.active = [];
        this.magnets.active = [];
        this.magnetActive = false;
        this.magnetTimer = 0;
        this.particles.active = [];
        
        // UI
        $('main-menu').classList.add('hidden');
        $('game-over-screen').classList.add('hidden');
        $('game-ui').classList.remove('hidden');
        $('joystick-zone').classList.remove('hidden');
        this.updateUI();
    },

    loop(timestamp) {
        let dt = (timestamp - this.lastTime) / 1000;
        if(dt > 0.1) dt = 0.1; // Cap lag
        this.lastTime = timestamp;

        if(this.state === 'PLAYING') {
            this.update(dt);
            this.draw();
        } else if(this.state === 'PAUSED') {
            this.draw(); // Still show game in background
        } else if(this.state === 'HACK') {
             // Slow mo draw
             this.draw();
             // Maybe slow update for background particles?
        }
        
        requestAnimationFrame(t => this.loop(t));
    },

    update(dt) {
        // Timers
        if(this.time > 0) {
            this.time -= dt;
            if(this.time <= 0) this.winLevel();
        }

        // Magnet timer
        if(this.magnetActive) {
            this.magnetTimer -= dt;
            if(this.magnetTimer <= 0) {
                this.magnetActive = false;
            }
        }

        // Wave-based spawning from multiple directions
        this.waveTimer -= dt;
        if(this.waveTimer <= 0) {
            let waveSize = CONFIG.ENEMIES_PER_WAVE + Math.floor(this.level / 2);
            for(let i = 0; i < waveSize; i++) {
                this.enemies.get();
            }
            this.waveTimer = CONFIG.ENEMY_SPAWN_RATE / 60; // Convert frames to seconds
        }

        // Updates
        this.player.update(dt);
        this.enemies.update(dt, this.ctx);
        this.bullets.update(dt, this.ctx);
        this.particles.update(dt, this.ctx);
        this.gems.update(dt, this.ctx);
        this.coins.update(dt, this.ctx);
        this.magnets.update(dt, this.ctx);

        // Collisions: Bullet vs Enemy
        this.bullets.active.forEach(b => {
             this.enemies.active.forEach(e => {
                 if(b.active && e.active && Dist(b.x, b.y, e.x, e.y) < (e.size + b.size)) {
                     let isDead = e.takeDamage(b.damage);
                     if(isDead) {
                         this.enemies.release(e); // Remove dead enemy from pool
                     }
                     if(!b.isOP) {
                         this.bullets.release(b); // Pierce if OP
                     }
                 }
             });
        });

        // XP Check
        if(this.xp >= this.maxXp) {
            this.startHack();
        }

        // Shake decay
        if(this.shake > 0) this.shake *= 0.9;
        if(this.shake < 0.5) this.shake = 0;

        this.updateUI();
    },

    draw() {
        let levelData = CONFIG.LEVELS[this.level-1];
        
        // Clear with level background
        this.ctx.fillStyle = levelData.bg;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw background grid pattern (different per level)
        this.ctx.strokeStyle = levelData.neon;
        this.ctx.globalAlpha = 0.05;
        this.ctx.lineWidth = 1;
        let gridSize = 50 + (this.level * 10);
        for(let x = 0; x < this.canvas.width; x += gridSize) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, this.canvas.height);
            this.ctx.stroke();
        }
        for(let y = 0; y < this.canvas.height; y += gridSize) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.canvas.width, y);
            this.ctx.stroke();
        }
        this.ctx.globalAlpha = 1;

        // Shake
        this.ctx.save();
        if(this.shake > 0) {
            this.ctx.translate(Rand(-this.shake, this.shake), Rand(-this.shake, this.shake));
        }

        // Draw entities
        this.particles.update(0, this.ctx); // Draw active particles
        this.enemies.update(0, this.ctx); // Just draw
        this.bullets.update(0, this.ctx); // Just draw
        this.gems.update(0, this.ctx); // Draw gems
        this.coins.update(0, this.ctx); // Draw coins
        this.magnets.update(0, this.ctx); // Draw magnets
        this.player.draw(this.ctx);
        
        // Magnet active indicator
        if(this.magnetActive) {
            this.ctx.strokeStyle = 'rgba(255, 0, 255, 0.3)';
            this.ctx.lineWidth = 3;
            this.ctx.beginPath();
            this.ctx.arc(this.player.x, this.player.y, 100, 0, Math.PI * 2);
            this.ctx.stroke();
            
            // Timer text
            this.ctx.fillStyle = '#f0f';
            this.ctx.font = 'bold 12px Courier New';
            this.ctx.textAlign = 'center';
            this.ctx.fillText('üß≤ ' + Math.ceil(this.magnetTimer) + 's', this.player.x, this.player.y - 35);
        }
        
        // Draw HP bar
        if(this.player.active) {
            let barWidth = 100;
            let barHeight = 8;
            let x = 10;
            let y = this.canvas.height - 20;
            
            // Background
            this.ctx.fillStyle = '#333';
            this.ctx.fillRect(x, y, barWidth, barHeight);
            
            // HP fill
            let hpPercent = Math.max(0, this.player.hp / 100);
            this.ctx.fillStyle = hpPercent > 0.3 ? '#0f0' : '#f00';
            this.ctx.fillRect(x, y, barWidth * hpPercent, barHeight);
            
            // Border
            this.ctx.strokeStyle = '#0f0';
            this.ctx.lineWidth = 1;
            this.ctx.strokeRect(x, y, barWidth, barHeight);
            
            // HP text
            this.ctx.fillStyle = '#fff';
            this.ctx.font = '10px Courier New';
            this.ctx.fillText(`HP: ${Math.floor(this.player.hp)}`, x + barWidth + 10, y + 7);
        }

        this.ctx.restore();
    },

    spawnParticles(x, y, color) {
        for(let i=0; i<8; i++) {
            let p = this.particles.get();
            p.reset(x, y, color);
        }
    },

    addScore(val) {
        this.score += val;
        this.xp += val;
    },
    
    addCoins(amount) {
        this.totalCoins += amount;
        // Save coins immediately
        this.saveProgress();
    },
    
    saveProgress() {
        localStorage.setItem('protocol_override_save', JSON.stringify({
            maxDayUnlocked: this.maxLevel,
            totalCoins: this.totalCoins,
            ownedSkins: this.ownedSkins,
            equippedSkinId: this.equippedSkinId
        }));
    },
    
    gameOver() {
        this.state = 'OVER';
        
        // Failure effect
        $('game-over-screen').style.background = 'rgba(50, 0, 0, 0.95)';
        $('go-title').innerText = '‚úó SYSTEM BREACHED';
        $('go-title').style.color = '#f00';
        
        let survived = Math.floor(CONFIG.DAY_DURATION - this.time);
        let needed = CONFIG.DAY_DURATION;
        let msg = 'SURVIVED: ' + survived + 's / ' + needed + 's';
        msg += '\n\nYou were ' + (needed - survived) + 's away from victory!';
        $('go-score').innerText = msg;
        $('go-score').style.color = '#f88';
        
        $('game-over-screen').classList.remove('hidden');
        $('game-ui').classList.add('hidden');
    },

    createFloater(text, x, y) {
        let el = document.createElement('div');
        el.className = 'floater';
        el.innerText = text;
        el.style.left = x + 'px';
        el.style.top = y + 'px';
        el.style.color = '#fff';
        document.body.appendChild(el);
        setTimeout(() => el.remove(), 800);
    },

    startHack() {
        this.state = 'HACK';
        this.xp = 0; // Reset XP
        this.maxXp *= 1.5; // Harder next time
        
        // Show Modal
        const qData = TRIVIA_DB[Math.floor(Math.random() * TRIVIA_DB.length)];
        $('hack-question').innerText = qData.q;
        $('hack-options').innerHTML = '';
        
        qData.a.forEach((ans, idx) => {
            let btn = document.createElement('button');
            btn.className = 'hack-btn';
            btn.innerText = ans;
            btn.onclick = () => this.resolveHack(idx === qData.correct);
            $('hack-options').appendChild(btn);
        });

        $('hack-modal').classList.remove('hidden');
        
        // Timer
        let timeLeft = 10.0;
        const bar = $('timer-fill');
        
        // Clear old interval if any
        if(this.hackTimer) clearInterval(this.hackTimer);
        
        this.hackTimer = setInterval(() => {
            timeLeft -= 0.05;
            bar.style.width = (timeLeft/10 * 100) + '%';
            if(timeLeft <= 0) {
                this.resolveHack(false);
            }
        }, 50);
    },

    resolveHack(success) {
        clearInterval(this.hackTimer);
        $('hack-modal').classList.add('hidden');
        this.state = 'PLAYING';
        
        if(success) {
            // DOPAMINE
            this.player.hasOpWeapon = true;
            this.player.opTimer = 15;
            
            // Flash screen
            let flash = document.createElement('div');
            flash.style.position = 'fixed';
            flash.style.top=0; flash.style.left=0;
            flash.style.width='100%'; flash.style.height='100%';
            flash.style.background='#fff';
            flash.style.zIndex=999;
            flash.style.opacity=0.8;
            flash.style.transition='opacity 0.5s';
            document.body.appendChild(flash);
            setTimeout(() => { flash.style.opacity=0; setTimeout(()=>flash.remove(),500); }, 50);
            
            this.createFloater("OVERRIDE EXECUTED!", this.canvas.width/2, this.canvas.height/2);
        } else {
            this.createFloater("ACCESS DENIED", this.canvas.width/2, this.canvas.height/2);
            // Small speed boost pity prize
            CONFIG.PLAYER_SPEED += 0.5;
        }
    },

    winLevel() {
        this.state = 'OVER';
        let unlockedNew = false;
        if(this.level >= this.maxLevel && this.level < 10) {
            this.maxLevel = this.level + 1;
            unlockedNew = true;
        }
        this.saveProgress(); // Save coins and progress
        
        // Celebration effect
        $('game-over-screen').style.background = 'rgba(0, 50, 0, 0.95)';
        $('go-title').innerText = "‚úì SYSTEM SECURED";
        $('go-title').style.color = '#0f0';
        
        let msg = "DAY " + this.level + " COMPLETE!";
        if(unlockedNew && this.level < 10) {
            msg += "\n\n‚òÖ DAY " + this.maxLevel + " UNLOCKED ‚òÖ";
        } else if(this.level === 10) {
            msg += "\n\nüèÜ ALL DAYS COMPLETE üèÜ";
        }
        $('go-score').innerText = msg;
        $('go-score').style.color = '#0ff';
        $('game-over-screen').classList.remove('hidden');
        $('game-ui').classList.add('hidden');
    },

    returnToMenu() {
        this.state = 'MENU';
        // Reset styles
        $('game-over-screen').style.background = 'rgba(0, 0, 0, 0.9)';
        $('go-title').style.color = 'var(--neon-green)';
        $('go-score').style.color = 'var(--neon-green)';
        
        $('game-over-screen').classList.add('hidden');
        $('pause-screen').classList.add('hidden');
        $('game-ui').classList.add('hidden');
        $('main-menu').classList.remove('hidden');
        this.renderMenu();
    },
    
    pauseGame() {
        if(this.state === 'PLAYING') {
            this.state = 'PAUSED';
            $('pause-screen').classList.remove('hidden');
        }
    },
    
    resumeGame() {
        if(this.state === 'PAUSED') {
            this.state = 'PLAYING';
            $('pause-screen').classList.add('hidden');
        }
    },
    
    pauseGame() {
        if(this.state === 'PLAYING') {
            this.state = 'PAUSED';
            $('pause-screen').classList.remove('hidden');
        }
    },
    
    resumeGame() {
        if(this.state === 'PAUSED') {
            this.state = 'PLAYING';
            $('pause-screen').classList.add('hidden');
        }
    },

    renderMenu() {
        const grid = $('level-select');
        grid.innerHTML = '';
        for(let i=1; i<=10; i++) {
            let btn = document.createElement('button');
            btn.className = 'btn';
            
            if(i > this.maxLevel) {
                btn.disabled = true;
                btn.innerText = "üîí DAY " + i;
                btn.style.opacity = 0.5;
                btn.style.borderColor = '#444';
            } else {
                const levelNum = i;
                const levelData = CONFIG.LEVELS[i-1];
                btn.innerText = "DAY " + i + "\n" + levelData.theme;
                btn.style.borderColor = levelData.neon;
                btn.style.color = levelData.neon;
                btn.style.fontSize = '14px';
                btn.style.whiteSpace = 'pre-line'; // Capture level in closure
                btn.addEventListener('click', () => {
                    Game.startLevel(levelNum);
                });
            }
        grid.appendChild(btn);
        }
        // Update coins display on menu
        $('menu-coins').innerText = this.totalCoins;
    },

    // ==================== SHOP SYSTEM ====================
    
    /**
     * Opens the shop screen
     */
    openShop() {
        this.state = 'SHOP';
        $('main-menu').classList.add('hidden');
        $('shop-screen').classList.remove('hidden');
        this.renderShop();
    },
    
    /**
     * Closes shop and returns to main menu
     */
    closeShop() {
        this.state = 'MENU';
        $('shop-screen').classList.add('hidden');
        $('main-menu').classList.remove('hidden');
        this.renderMenu();
    },
    
    /**
     * Renders the shop with all available skins
     */
    renderShop() {
        const grid = $('skin-grid');
        grid.innerHTML = '';
        
        // Update coins display
        $('shop-coins').innerText = this.totalCoins;
        
        SKINS_CONFIG.forEach(skin => {
            const isOwned = this.ownedSkins.includes(skin.id);
            const isEquipped = this.equippedSkinId === skin.id;
            const canAfford = this.totalCoins >= skin.price;
            
            // Create skin card
            const card = document.createElement('div');
            card.className = 'skin-card' + (isEquipped ? ' equipped' : isOwned ? ' owned' : '');
            
            // Character preview (simplified visual)
            const preview = document.createElement('div');
            preview.className = 'preview';
            preview.innerHTML = `
                <svg width="50" height="70" viewBox="0 0 50 70">
                    <!-- Head -->
                    <circle cx="25" cy="12" r="10" fill="${skin.colors.head}"/>
                    <!-- Body -->
                    <rect x="15" y="22" width="20" height="25" fill="${skin.colors.body}"/>
                    <!-- Arms -->
                    <line x1="15" y1="28" x2="5" y2="40" stroke="${skin.colors.arms}" stroke-width="4" stroke-linecap="round"/>
                    <line x1="35" y1="28" x2="45" y2="40" stroke="${skin.colors.arms}" stroke-width="4" stroke-linecap="round"/>
                    <!-- Legs -->
                    <line x1="20" y1="47" x2="15" y2="65" stroke="${skin.colors.legs}" stroke-width="4" stroke-linecap="round"/>
                    <line x1="30" y1="47" x2="35" y2="65" stroke="${skin.colors.legs}" stroke-width="4" stroke-linecap="round"/>
                    <!-- Eyes -->
                    <circle cx="22" cy="11" r="2" fill="#fff"/>
                    <circle cx="28" cy="11" r="2" fill="#fff"/>
                </svg>
            `;
            card.appendChild(preview);
            
            // Skin name
            const name = document.createElement('div');
            name.className = 'skin-name';
            name.innerText = skin.name;
            card.appendChild(name);
            
            // Price (only show if not owned)
            if(!isOwned) {
                const price = document.createElement('div');
                price.className = 'skin-price';
                price.innerText = 'üí∞ ' + skin.price;
                card.appendChild(price);
            }
            
            // Action button
            const btn = document.createElement('button');
            btn.className = 'skin-btn';
            
            if(isEquipped) {
                btn.className += ' equipped';
                btn.innerText = '‚úì ACTIVE';
                btn.disabled = true;
            } else if(isOwned) {
                btn.className += ' equip';
                btn.innerText = 'EQUIP';
                btn.onclick = () => this.equipSkin(skin.id);
            } else if(canAfford) {
                btn.className += ' buy';
                btn.innerText = 'BUY';
                btn.onclick = () => this.buySkin(skin.id, skin.price);
            } else {
                btn.className += ' locked';
                btn.innerText = 'LOCKED';
                btn.disabled = true;
            }
            card.appendChild(btn);
            
            grid.appendChild(card);
        });
    },
    
    /**
     * Purchase a skin
     * @param {string} skinId - The ID of the skin to purchase
     * @param {number} price - The cost in coins
     * @returns {boolean} - Whether purchase was successful
     */
    buySkin(skinId, price) {
        // Validate: Check if already owned
        if(this.ownedSkins.includes(skinId)) {
            console.warn('Skin already owned:', skinId);
            return false;
        }
        
        // Validate: Check if enough coins
        if(this.totalCoins < price) {
            this.createFloater('NOT ENOUGH COINS!', window.innerWidth/2, window.innerHeight/2);
            return false;
        }
        
        // Deduct coins
        this.totalCoins -= price;
        
        // Add to owned skins
        this.ownedSkins.push(skinId);
        
        // Auto-equip the newly purchased skin
        this.equippedSkinId = skinId;
        
        // Persist to storage
        this.saveProgress();
        
        // Visual feedback
        this.createFloater('SKIN UNLOCKED!', window.innerWidth/2, window.innerHeight/2);
        
        // Re-render shop to update UI
        this.renderShop();
        
        return true;
    },
    
    /**
     * Equip an owned skin
     * @param {string} skinId - The ID of the skin to equip
     * @returns {boolean} - Whether equip was successful
     */
    equipSkin(skinId) {
        // Validate: Check if skin is owned
        if(!this.ownedSkins.includes(skinId)) {
            console.warn('Skin not owned:', skinId);
            return false;
        }
        
        // Update equipped skin
        this.equippedSkinId = skinId;
        
        // Persist to storage
        this.saveProgress();
        
        // Re-render shop to update UI
        this.renderShop();
        
        return true;
    },

    updateUI() {
        $('score-display').innerText = "DATA: " + Math.floor((this.xp/this.maxXp)*100) + "%";
        let m = Math.floor(this.time / 60);
        let s = Math.floor(this.time % 60);
        $('time-display').innerText = `${m}:${s<10?'0'+s:s}`;
        $('xp-bar').style.width = Math.min(100, (this.xp/this.maxXp)*100) + "%";
        $('coin-display').innerText = 'üí∞ ' + this.totalCoins;
    }
};

// Start
window.onload = () => Game.init();

</script>
</body>
</html>
